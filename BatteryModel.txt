
using JuMP
using Gurobi
using DataFrames
using DataArrays

m = Model(solver=GurobiSolver())

iGenLoad = readtable("BatteryModel_GenLoad.csv",header=true)
iPrices = readtable("BatteryModel_Prices.csv",header=true)
iParameters = readtable("BatteryModel_Parameters.csv",header=true)

T = length(iPrices[:Hour]) 
pHours = iPrices[:Hour][1:T]


pBuyEnergy = iPrices[:pBuy_Energy][1:T]
pSellEnergy = iPrices[:pSell_Energy][1:T]
pNonControllableLoad = iGenLoad[:pNonControllableLoad][1:T]

pDelta = 1 #duration of time period (hr)
pCCurtail = 0.25 #cost of curtailment - will depend on the scenario ($/KWH)

Parameters to read in: 

Parameters: structure of energy costs 

Prices(buyE, sellE, buyNetwork, sellNetwork, capacity?x24) 
NonControllable Load (1x24)
NonControllable Gen (1x24) - includes PVWatts output... wind... whatever. 
Schedules for Schedulable Load(something...)
[building parameters]: Ambient Temp (1x24), Exogenous Internal Radiation and Convection Gains (per zone)(1x24), Gain coefficients (1 x number of parameters)
DES Parameters (however many) 


pGenAssets = [1 5 2.5 2.5] # this is where you specify the technology choices; will ultimately take this from dataframes
#genAssets = [pPVbank pBatt_NominalE pBatt_DischargeCapacity pBatt_ChargeCapacity]

pPV_Capacity = pGenAssets[1] #this is the total capacity of the PV panels 
pPV_Generation = pGenAssets[1]*iGenLoad[:pPV_Generation][1:T]

# declaring non-PV based non-controllable generation
pOtherNonControllableGen = iGenLoad[:pOtherNonControllableGen][1:T]

#total non-controllable generation = PV + other
@defExpr(pTotalNonControllableGen[t=1:T], pPV_Generation[t]+pOtherNonControllableGen[t])


pBattNominalE = pGenAssets[2]
pBattDischargeCapacity = pGenAssets[3] #installed battery discharge power capacity (KW)
pBattChargeCapacity = pGenAssets[4] #installed battery charge power capacity (KW)

#pBatt_DischargeEff Efficiency of battery discharge
#pBatt_ChargeEff Efficiency of battery charge
#pBatt_CDeg battery degradation cost ($) #SB!!! Seems an odd thing to specify. Maybe base it off of cycle life, etc.
#pBatt_InitialSOC initial state of charge 
#pBatt_SOCMax maximum SOC
#pBatt_SOCMin minimum SOC

pBattDischargeEff = iParameters[1,:pBatt_DischargeEff]
pBattChargeEff = iParameters[1,:pBatt_ChargeEff]
pBattCDeg = iParameters[1,:pBatt_CDeg]
pBattInitialSOC = iParameters[1,:pBatt_InitialSOC]
pBattSOCMax = iParameters[1,:pBatt_SOCMax]
pBattSOCMin = iParameters[1,:pBatt_SOCMin]

@defVar(m, vPowerCurtail[t=1:T] >= 0) #curtailed power
@defVar(m, vPowerConsumed[t=1:T] >=0) # consumed power
@defVar(m, vPowerImportorExport[t=1:T], Bin)

@defVar(m, vPowerPurchased[t=1:T] >=0) # power ultimately purchased from utility

@defVar(m, vBattSOC[t=1:T] >= 0) # SOC of battery ----- SB!!! Maybe make this a state variable, not a decision variable.
@defVar(m, vBattSOH[t=1:T] >= 0) #State of health of battery (degradation costs)
@defVar(m, vBattCharge[t=1:T] >= 0) #battery charging power
@defVar(m, vBattDischarge[t=1:T] >= 0) #battery discharging power
# @defVar(m, vBatt_Demand[t=1:T] >= 0) #load SB!!! confused by this for now
@defVar(m, vBattCorD[t=1:T], Bin) #batt charging or discharging binary variable. 
# @defVar(m, Bbd[t=1:T], Bin) #batt discharge - unclear if we need this.


for t=1:T
    @addConstraint(m, vPowerConsumed[t] == pNonControllableLoad[t] + vBattCharge[t]) # + vScheduledLoads[t] + ThermalLoads[t] would normally include flexible load
end

@defExpr(sPowerProduced[t=1:T], pTotalNonControllableGen[t] + vBattDischarge[t])

@defExpr(sPowerExport[t=1:T], vPowerConsumed[t]-sPowerProduced[t])
 

#for t=1:T
#    if (pTotalNonControllableGen[t] + pBatt_NominalE) > 0
#        @addConstraint(m, sPowerExport[t] == sPowerProduced[t]-vPowerConsumed[t])
#    else 
#        @addConstraint(m, sPowerExport[t] == 0)
#    end
#end

#for t=1:T
@defExpr(sPowerPurchase[t=1:T], vPowerConsumed[t]-sPowerProduced[t])
#end

for t=1:T
    @addConstraint(m, sPowerExport[t]+sPowerPurchase[t] == vPowerConsumed[t]+sPowerProduced[t])
end

for t=1:T
    @addConstraint(m, sPowerExport[t] <= 10000000*(1-vPowerImportorExport[t]))
    @addConstraint(m, sPowerPurchase[t] <= 10000000*(vPowerImportorExport[t]))
end


#constraining state of charge to appropriate limits
@addConstraint(m, vBattSOC[1] == pBattInitialSOC)

for t = 1:T
    @addConstraint(m, vBattSOC[t] <= pBattSOCMax)
    @addConstraint(m, vBattSOC[t] >= pBattSOCMin)
end 

# defining charging losses and efficiency
@defExpr(sBattDischargeLosses[t=1:T], pBattDischargeEff*vBattDischarge[t])
@defExpr(sBattChargeLosses[t=1:T], pBattChargeEff*vBattCharge[t])
@defExpr(sBattLosses[t=1:T], sBattChargeLosses[t] + sBattDischargeLosses[t])

@defExpr(sBattOutput[t=1:T], vBattDischarge[t] - sBattDischargeLosses[t])
@defExpr(sBattInput[t=1:T], vBattCharge[t] + sBattChargeLosses[t])
        

if pBattNominalE > 0
    for t = 2:T  
        @addConstraint(m, vBattSOC[t-1] - (pDelta/pBattNominalE)*(sBattOutput[t-1] - sBattInput[t-1] + sBattLosses[t-1]) == vBattSOC[t])
    end 
else 
    for t = 2:T
        @addConstraint(m, vBattSOC[t] == vBattSOC[1])
    end 
end 

#define charge or discharge constraint
for t=1:T
    @addConstraint(m, vBattCharge[t] <= 1000000*vBattCorD[t])
    @addConstraint(m, vBattDischarge[t] <= 1000000*(1-vBattCorD[t]))
end



@defExpr(TotalCost,sum{pDelta*pBuyEnergy[t]*sPowerPurchase[t] + pDelta*pSellEnergy[t]*sPowerExport[t],t=1:T})

@setObjective(m, Min, TotalCost)
# + PowerImport*PowerBuyPrice(t) + PowerExport*PowerSellPrice(t) + Fixed(t) )

solve(m)


